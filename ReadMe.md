Задание ТКПА. 
Qt версия 5.12.2.
Модульные тесты - QTest.

Проект представляет собой многооконное приложение на Qt, реализующее пять учебных заданий по алгоритмам и структурам данных.  
Каждое задание решается в отдельном виджете, доступном из главного меню.

Тесты. 
Для того, чтобы просмотреть выполнение тестов необходимо в main.cpp закомментировать main: 
/*int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    MainWindow w;
    w.show();
    return app.exec();
}*/
А в testtask.cpp раскомментировать QTEST_MAIN(testtask)

Как собрать.
1. Откройте `TestApp.pro` в Qt Creator
2. Выберите компилятор (MinGW)
3. Нажмите "Rebuild"
4. Запустите


1 Задание. Напишите функцию, которая вычисляет первые N простых чисел и размещает их в массив.

   - Определение, является ли число простым ("isPrime")
   - Поиск первых N простых чисел ("findFirstNPrimes")

После нажатия кнопки "Вычислить" будет предложено сохранить файл, файл сохраняется в папку сборки

2 Задание. Напишите функцию, которая посчитывает количество слов в тексте и их длину (X слов с длиной 1 символ, Y слов длиной 2 символа и так далее).

   - Удаление знаков препинания, пробелов и табуляций 
   - Подсчёт количества слов длиной 1, 2, 3 и т.д.

Словом считается любой набор букв и чисел, разделенный пробелами. Было принято цифры и числа считать за слова.

3 Задание. "Дан список:
                   struct List {
                       struct List* next;
                       SomeDataType payload;
                   };
                   Напишите функцию, которая удаляет каждый пятый (5) элемент из данного списка.

   - Построение списка из строки
   - Удаление каждого пятого элемента

4 Задание. Напишите функцию, которая принимает 32-битное целое число без знака и возвращает максимальное и минимальное 32-битное целое число без знака, которые могут быть получены с помощью того же количества бит, установленных в 1, как в взятом числе.

   - Подсчёт единиц в двоичной записи
   - Поиск минимального и максимального числа с тем же количеством единиц

5 Задание. Дано бинарное дерево:
                   struct TreeNode {
                       struct TreeNode* leftChild;
                       struct TreeNode* rightChild;
                   };
                   Напишите функцию подсчёта глубины дерева (максимальное количество узлов на пути от корневого узла до листа). Решение должно возвращать все пути в дереве, имеющие такую глубину.

   - Парсинг дерева в скобочной записи (например, A(B(D),C(E,F)))
   - Поиск всех путей максимальной длины от корня до листьев

